\Sexpr{set_parent('Lock5withR.Rnw')}
\Chapter{Describing Data}

In this chapter we discuss graphical and numerical summaries of data. 
%These notes focus primarily on how to get \R\ to do the work for you. The text book includes more information about why and when to use various kinds of summaries.


<<>>=
dotPlot( ~TV , data=StudentSurvey, groups = (3 <= TV & TV <= 15 ), width=.5)
@

\section{Categorical Variables}

%Introduction to Categorial Variables?


\subsection*{One Categorical Variable}

Let us investigate categorical variables in \R\ by taking a look at the data set for the One True Love survey. Notice that the data set is not readily available in our textbook's package. However, the authors do provide us with the necessary information to create our own data spreadsheet (in either Excel or Google) and import it into \R. (See Chapter 0 for instructions.) %One could also use any other data set as an example.

From the dataset we named as \dataframe{OneTrueLove}, we can tabulate the categorical variable to display the \emph{frequency} by using the \function{tally()} function.
<<tally-1way>>=
OneTrueLove <- read.file( "OneTrueLove.csv" )
tally(~ Response, data=OneTrueLove)
@
Note the use of the \R\ template in Chapter 0.

Similarily, we can also display the \emph{relative frequencies}, or \term{proportions}.
<<tally-1way-proportion>>=
tally(~ Response, format="proportion", data=OneTrueLove)
@

In addition to manually calculating the proportion, we can use the \function{prop()} function.
<<prop-1way>>=
prop(~ Response, data=OneTrueLove)
@
%how to display disagree/don't know?
%more on prop in chapter 3 guide..


\subsubsection*{Visualizing the Data in One Categorical Variable}

To visualize counts or proportions, \R\ provides many different chart and plot functions, including \emph{bar charts} and \emph{pie charts}. Bar charts, also known as bar graphs, are a way of displaying the distribution of a categorical variable.

<<bargraph>>=
bargraph(~ Response, data=OneTrueLove)
bargraph(~ Response, data=OneTrueLove, horizontal=TRUE)
@

%Here is an example of a pie chart, but note that statisticians rarely use pie charts because they are harder to read.
%Include pie chart?
%<<piechart>>=
%slices <- c(78, 1812, 735) # assigning vectors of the area of each slice
%lbls <- c("Don't know", "Disagree", "Agree") # assigning vectors of labels of corresponding slice
%pie(slices, labels = lbls) # plotting "slices" for a pie chart
%@


\subsection*{Two Categorical Variables: Two-Way Tables}

Often, it is useful to compute cross tables for two (or more) variables. We can again use \function{tally()} for several ways to investigate a two-way table.
<<tally-2way>>=
tally(~ Response + Gender, data=OneTrueLove)
tally(Response ~ Gender, data=OneTrueLove)
tally(~ Response | Gender, data=OneTrueLove)
@

Notice that (by default) some of these us counts and some use proportions.
If you don't like the defaults, or if you don't want the row and column totals (called marginal
totals), we can change the defaults by adding a bit more instruction.
<<tally-2way-options>>=
tally(~ Gender + Award, data=StudentSurvey, margins=FALSE, format="percent")
@

We can arrange the table differently by converting it to a data frame.
<<tally-2way-data-frame>>=
as.data.frame(tally(~ Gender + Award, data=StudentSurvey))
@

Again, we can calculate the proportions of two categorical variables.
<<prop-2way>>=
prop(Response~Gender, data=OneTrueLove)
@

%difference in prop-- how to manipulate the prop? diff(prop(Award~Gender, data=StudentSurvey))

\subsubsection*{Visualizing a Relationship between Two Categorical Variables}

A way to look at multiple groups simultaneously is by using \emph{comparative plots} such as a \emph{segmented bar chart} or \emph{side-by-side bar chart}. (We will discuss grouping more in section 2.4.)
Any way to segment using mosaic?
<<bargraph-segmented>>=
counts <- table(StudentSurvey$Gender, StudentSurvey$Award)
barplot(counts, legend = rownames(counts)) 
@

<<>>=
bargraph(~Award, data=StudentSurvey, group=Gender, stack=TRUE)
@

We use \argument{auto.key=TRUE} to build a simple legend so we can tell which groups are which.
<<bargraph-groups>>=
bargraph(~ Gender, groups=Award, data=StudentSurvey, auto.key=TRUE)
@



\section{One Quantitative Variable: Shape and Center}

\begin{boxedText}
The distribution of a variable answers two questions:
\begin{itemize}
\item
\emph{What values} can the variable have?
\item
\emph{With what frequency} does each value occur?

Again, the frequency may be described in terms of counts, proportions (often called 
relative frequency), or densities (more on densities later).
\end{itemize}
\end{boxedText}

A distribution may be described using a table (listing values and frequencies)
or a graph (e.g., a histogram) or with words that describe general features 
of the distribution (e.g., symmetric, skewed).


\subsection*{The Shape of a Distribution}

Statisticians have devised a number of graphs to help us see distributions visually.  
The general syntax for making a graph of one variable in a data frame is
<<eval=FALSE>>=
plotname(~ variable, data=dataName)
@

In other words, there are three pieces of information we must provide to 
\R\ in order to get the plot we want:
\begin{itemize}
  \item
		The kind of plot (\function{histogram()}, \function{bargraph()}, 
		\function{densityplot()}, \function{bwplot()}, etc.)
	\item
		The name of the variable 
	\item
		The name of the data frame this variable is a part of.
\end{itemize}


\subsubsection*{Dot Plot}
Let's take first make a \emph{dot plot} of the variable Longevity in the \dataframe{MammalLongevity} data set for a quick and simple look at the distribution.
<<dotplot, warning=FALSE>>=
MammalLongevity
dotPlot(~ Longevity, width=1, center=.5, data = MammalLongevity)
@
%fix dotplot so it looks better


\subsubsection*{Histograms and Density Plots}

Although \function{tally()} works with quantitative variables
as well as categorical variables, this is only useful when there are not too
many different values for the variable.

<<xtabs-quantitative>>=
tally(~ Longevity, data=MammalLongevity)
@

Sometimes, it is more convenient to group them into bins.  We just have to tell \R\ what the bins are.
For example, suppose we wanted to group together by 5.
\Rindex{cut()}%
\Rindex{tally()}%
<<cut>>=
binnedLong <- cut(MammalLongevity$Longevity, breaks=c(0,5,10,15,20,25,30,35,40))
tally(~ binnedLong)      # no data frame given because its not in a data frame
@

Suppose we wanted to group the 1s, 10s, 20s, etc. together. We want to make sure then that 10 is with the 10s, so we should add another argument.
<<cut2>>=
binnedLong2 <- cut(MammalLongevity$Longevity, breaks=c(0,10,20,30,40,50), right=FALSE)
tally(~ binnedLong2)      # no data frame given because it's not in a data frame
@

We won't use this very often however, since seeing this information in a histogram is typically more useful.  

Histograms are a way of displaying the distribution of a quantitative 
variable. Here are a couple examples:
<<histogram>>=
histogram(~ Longevity, data = MammalLongevity)
histogram(~ age, data=HELPrct)
@
%explain HELPrct? Or refer to Chapter 0?

We can control the (approximate) number of bins using the \option{nint} 
argument, which may be abbreviated as \option{n}.
The number of bins (and to a lesser extent the positions of the bins)
can make a histogram look quite different.
<<histogram2, fig.width=3, out.width='.3\\textwidth', warning=FALSE>>=
histogram(~ Longevity, type="count", data=MammalLongevity, n=8)
histogram(~ Longevity, type="count", data=MammalLongevity, n=15)
histogram(~ Longevity, type="count", data=MammalLongevity, n=30)
@
%Fix center of histogram--histogram( ~ Longevity, type="count", data=MammalLongevity, width=5, center=2.5)?

We can also describe the bins in terms of center and width instead of in terms of the number
of bins.  This is especially nice for count or other integer data.
<<xhistogram,fig.width=3,out.width='.3\\textwidth', warning=FALSE>>=
histogram(~ Longevity, type="count", data=MammalLongevity, width=10)
histogram(~ Longevity, type="count", data=MammalLongevity, width=5)
histogram(~ Longevity, type="count", data=MammalLongevity, width=2)
@

We can illustrate Example 2.9. Note the various options available for the \function{histogram()} function enable us to replicate Figure 2.8.
<<Example2.9,fig.width=3,out.width='.3\\textwidth', warning=FALSE>>=
histogram(~ Pulse, type='count', width=5, label=TRUE, data=StudentSurvey)
histogram(~ Exercise, type='count', width=2, center=2, label=TRUE, 
          right=FALSE, ylim=c(0,70), data=StudentSurvey) 
histogram(~ Piercings, data=StudentSurvey, width=1)
@

%The \function{histogram()} function offers you the option of 
%adding the counts to the graph.
%<<histogram-counts,fig.width=6,warning=FALSE>>=
%histogram(~ age, data=HELPrct, label=TRUE, type='count', 
%       width=10, center=5, ylim=c(0,300), right=FALSE )
%@

Sometimes a \term{frequency polygon} provides a more useful view.
The only thing that changes is \function{histogram()} becomes \function{freqpolygon()}.
<<freqpolygon,fig.width=3,out.width='.3\\textwidth'>>=
freqpolygon(~ age, data=HELPrct, width=5)
@

What is a frequency polygon?  The picture below shows how it is related to a histogram.  The frequency
polygon is just a dot-to-dot drawing through the centers of the tops of the bars of the histogram.
<<freqpolygon-illustrated,fig.width=8, fig.height=3, out.height="3in", fig.align="center", echo=FALSE>>=
freqpolygon(~ age, data=HELPrct, breaks=seq(10,70,by=4), lwd=3, par.settings=col.whitebg(), 
             panel=function(x,...) { 
  panel.xhistogram(x,...);
  panel.freqpolygon(x,...)}
             )
@

\R\ also provides a ``smooth'' version called a density plot; just change 
the function name from \function{histogram()} to \function{densityplot()}.
<<densityplot, fig.width=3,out.width='.3\\textwidth'>>=
densityplot(~ Longevity, data=MammalLongevity)
densityplot(~ BirthRate, data=AllCountries )
densityplot(~ age, data=HELPrct )
@

If we make a histogram (or any of these other plots) 
of our data, we can describe the overall shape of the distribution.
Keep in mind that the shape of a particular histogram may depend on the choice of bins.
Choosing too many or too few bins can hide the true shape of the distribution.  (When in doubt, make
more than one histogram.)

Here are some words we use to describe shapes of distributions.
\begin{description}
\item[symmetric] The left and right sides are mirror images of each other.
\item[skewed] The distribution stretches out farther in one direction than in the other.  
(We say the distribution is skewed toward the long tail.)
\item[uniform] The heights of all the bars are (roughly) the same.  
(So the data are equally likely to be anywhere within some range.)
\item[unimodal] There is one major ``bump'' where there is a lot of data.
\item[bimodal] There are two ``bumps''.
\item[outlier] An observation that does not fit the overall pattern of the rest of 
the data.
\end{description}



\subsection*{The Center of a Distribution}

Recall that a statistic is a number computed from data. The \term{mean} and the \term{median} are key statistics which describe the center of a distribution. We can see through Example 2.11 that numerical summaries are computed using the same template as graphical summaries.

\subsubsection*{Subsets}

Note however, that the example asks about subsets of \dataframe{ICUAdmissions}--specifically about 20-year-old and 55-year-old patients. In this case, we can manipulate the data (to name a new data set) with the subset command. Here are some examples.
\begin{enumerate}
  \item 
    Select only the males from the \dataframe{ICUAdmissions} data set.
<<>>=
tally(~ Sex, data=ICUAdmissions) 
ICUMales <- subset(ICUAdmissions, Sex=="Male") # notice the double =
dim(ICUMales)
@
	\item
		Select only the subjects over 50:
<<>>=
ICUold <- subset(ICUAdmissions, Age > 50) 
@
%	\item
%		Only the states (and Puerto Rico and District of Columbia) data from the US Census data set loaded %above.
%<<>>=
%tally( ~Sumlev, data=Population)
%States <- subset(Population, Sumlev==40)
%dim(States)
%@
\end{enumerate}
The \function{subset()} function can use any condition that evaluates to TRUE or FALSE for each row (case) in the data set.

<<center>>=
ICU20 <- subset(ICUAdmissions, Age=="20")
mean(~HeartRate, data=ICU20)
median(~HeartRate, data=ICU20)
ICU55 = subset(ICUAdmissions, Age=="55")
mean(~HeartRate, data=ICU55)
median(~HeartRate, data=ICU55)
@

\subsubsection*{Visualizing the Mean and Median on a Graph}

Let's take a look at Example 2.14 for an illustration of the mean and median.
<<FloridaLakes-example, warning=FALSE>>=
head(FloridaLakes)
histogram(~Alkalinity, width=10, type="count", data=FloridaLakes)
mean(~Alkalinity, data=FloridaLakes)
median(~Alkalinity, data=FloridaLakes)
@



\section{One Quantitative Variable: Measures of Spread}

In the previous section, we investigated center summary statistics. In this section, we will cover some other important statistics.
<<numerical-summaries>>=
summary(April14Temps)
favstats(~DesMoines, data=April14Temps) # some favorite statistics
@


\subsection*{Standard Deviation}

First, the density plots of the temperatures of Des Moines and San Francisco reveal that Des Moines has a greater \emph{variability} or \emph{spread}.
<<sd-exploration, echo=FALSE>>=
densityplot(~ DesMoines, xlim=c(20, 90), data=April14Temps)
densityplot(~ SanFrancisco, xlim=c(20, 90), data=April14Temps)
@

Although both \function{summary()} and \function{favstats()} calculate the \term{standard deviation} of a variable, we can also use the \function{sd()} to find just the standard deviation. 
<<standard-deviation>>=
sd(~DesMoines, data=April14Temps)        
sd(~SanFrancisco, data=April14Temps)
var(~DesMoines, data=April14Temps)        # variance = sd^2
@

%<<>>=
%dotPlot(~ DesMoines, data=April14Temps)
%dotPlot(~ SanFrancisco, data=April14Temps)
%@

Let's also take a look at Example 2.17.
<<Example2.17>>>=
densityplot(~ Pulse, data=StudentSurvey)
histogram(~ Pulse, data=StudentSurvey)
plotDist("norm")
mean(~Pulse, data=StudentSurvey)
sd(~Pulse, data=StudentSurvey)
@
%how to fit a normal curve to histogram?
%easy way to compute 2 or 3 sd?

%include Example 2.18?

%how to include z-scores with R?


\subsection*{Percentile}
In Example 2.20, the text uses a histogram to estimate the \term{percentile} of the daily closing price for the S&P 500. We can also find the exact percentiles using the \function{quantile()} function. 
<<percentile, warning=FALSE>>=
histogram(~Close, type="count", data=SandP500)
quantile(SandP500$Close, probs=seq(0, 1, 0.25))
quantile(SandP500$Close, probs=seq(0, 1, 0.90))
@


\subsection*{Five Number Summary}

We have already covered many different functions which results in the \term{five number summary} but \function{fivenum()} is most direct way to obtain in the five number summary. 
<<five-number-summary>>=
fivenum(~Longevity, data=MammalLongevity)
min(~Longevity, data=MammalLongevity) 
max(~Longevity, data=MammalLongevity) 
range(~Longevity, data=MammalLongevity)  # subtract to get the numerical range value
iqr(~Longevity, data=MammalLongevity)   # inter-quartile range 
@
%the range and iqr do not match the book b/c the book uses different quartiles
%several different methods, iqr different

\offNote{example}

\section{Outliers, Boxplots, and Quantitative/Categorical Relationships}

\subsection*{Detection of Outliers}

Generally, outliers are considered to be values 
\begin{itemize}
\item less than Q_1 - 1.5(IQR), and 
\item 
greater than Q_3 + 1.5(IQR).
\end{itemize}

There is no function in \R\ that directly results in outliers because practically, there is no one specific formula for such a determination. However, a boxplot will indirectly reveal outliers using the method above.

\subsection*{Boxplots}

A way to visualize the five number summary and outliers for a variable is to create a boxplot.
<<boxplot>>=
favstats(~Longevity, data=MammalLongevity)
bwplot(~Longevity, data=MammalLongevity)
@

We can similarity investigate the \emph{Smokers} variable in \dataframe{USStates}.
<<boxplot2>>=
bwplot(~Smokers, data=USStates)
@

The boxplot reveals two outliers. To identify them, we can again use \function{subset()} for smokers greater or less than the \emph{whiskers} of the boxplot.
<<subset-outliers>>=
subset(USStates, Smokers<15)
subset(USStates, Smokers>28)
@

%include Example 2.28?

\subsection*{Quantitative and Categorical Variables}

\subsubsection*{Conditional plots}
The formula for a \pkg{lattice} plot can be extended to create multiple panels 
(sometimes called \term{facets})
based on a ``condition'', often given by another variable.  The 
general syntax for this becomes
<<eval=FALSE>>=
plotname( ~ variable | condition, data=dataName )
@

For example, we might like to see whether the number of hours spent watching tv differ between men and women in the Student Survey, or how the distribution of birth rates compare between countries at different stages of development.
<<conditionalplots>>=
bwplot(Gender ~ TV, data=StudentSurvey)
histogram(~BirthRate | Developed, data=AllCountries, auto.key=TRUE, width=5)
dotPlot(~TV|Gender, layout=c(1,2), width=1.5, data = StudentSurvey)
@

We can do the same thing for bar graphs.
<<conditionalplot-categorical>>=
bargraph(~ Award | Gender, data=StudentSurvey)
@
This graph should be familiar as we have plotted these variables together previously. Here we used different panels, but before, in 2.1, we had used grouping. 

%how to create a side-by-side bwplot?

\subsubsection*{Grouping}
Another way to look at multiple groups simultaneously is by using 
the \argument{groups} argument.  What groups does depends a bit on the type of 
graph, but it will put the information in one panel rather than multiple panels.
Using \argument{groups} with \function{histogram()} doesn't work so well because
it is difficult to overlay histograms.%
\footnote{The \pkg{mosaic} function
\function{histogram()} does do something meaningful with \argument{groups}
in some situations.}
Density plots work better for this.

Here are some examples using the \dataframe{HELPrct} data frame. Again, we use \argument{auto.key=TRUE} to build a simple legend so we can tell which groups are which.
<<groups>>=
bargraph(~substance, groups=sex, data=HELPrct, auto.key=TRUE)
densityplot(~age, groups=sex, data=HELPrct, auto.key=TRUE)
@

We can even combine grouping and conditioning in the same plot.
<<groups-conditions,fig.width=6,fig.height=2.5>>=
densityplot(~age|sex, groups=substance, data=HELPrct, auto.key=TRUE)
@
<<groups-conditions2,fig.width=6,fig.height=2.5>>=
densityplot(~age|substance, groups=sex, data=HELPrct, auto.key=TRUE, layout=c(3,1))
@
This plot shows that for each substance, the age distributions of men and 
women are quite similar, but that the distributions differ from 
substance to substance.



\section{Two Quantitative Variables: Scatterplot and Correlation}


\subsection*{Visualizing a Relationship between Two Quantitative Variables: Scatterplots}

The most common way to look at two quantitative variables is with a 
scatterplot.  The \pkg{lattice} function for this is \function{xyplot()}, 
and the basic syntax is
<<xyplot-syntax, eval=FALSE>>=
xyplot(yvar ~ xvar, data=dataName)
@

Notice that now we have something on both sides of the \~{} since we need to tell
\R\ about two variables.  
<<xyplot1>>=
xyplot(Margin ~ Approval, data=ElectionMargin)
@

Grouping and conditioning work just as before.
With large data set, it can be helpful to make the dots semi-transparent so it is
easier to see where there are overlaps.  This is done with \argument{alpha}.
We can also make the dots smaller (or larger) using \argument{cex}.
<<xyplot2,fig.width=6,fig.height=3>>=
xyplot( mcs ~ age | sex, groups=substance, data=HELPrct, alpha=.6, cex=.5, 
	   auto.key=TRUE )
@

Here are some additional scatterplots from Example 2.34 to study the differences in strengh and direction of the associations.
<<xyplot3>>=
xyplot(AvgMercury ~ pH, data = FloridaLakes)
xyplot(AvgMercury ~ Alkalinity, data = FloridaLakes)
xyplot(Alkalinity ~ pH, data = FloridaLakes)
xyplot(AvgMercury ~ ThreeYrStdMercury, data = FloridaLakes)
@

\subsection*{Summarizing a Relationship between Two Quantitative Variables: Correlation}

Another key numerical statistic is the \term{correlation}--the correlation is a measure of the strength and direction of the relationship between two quantitative variables.
<<correlation>>=
cor(Margin ~ Approval, data = ElectionMargin)
cor(AvgMercury ~ pH, data = FloridaLakes)
cor(AvgMercury ~ Alkalinity, data = FloridaLakes)
cor(Alkalinity ~ pH, data = FloridaLakes)
cor(AvgMercury ~ ThreeYrStdMercury, data = FloridaLakes)
@

\subsubsection*{Cricket Chirps and Temperature}

We can now easily explore Example 2.35.
<<Example2.35>>=
CricketChirps
xyplot(Temperature ~ Chirps, data = CricketChirps)
cor(Temperature ~ Chirps, data = CricketChirps)
@

\subsubsection*{Effects of Diet on Levels of Retinol and Beta-carotene}

Further, using the \function{subset()} function again, we can investigate the correlation between variables with some restrictions.
<<>>=
xyplot(Alcohol ~ Calories, data=subset(NutritionStudy, Age>59))
cor(Alcohol ~ Calories, data=subset(NutritionStudy, Age>59))
@

And now we omit the outlier
<<omitoutlier>>=
NutritionStudy60 = subset(NutritionStudy, Age>59)
xyplot(Alcohol ~ Calories, data=subset(NutritionStudy60, Alcohol<25))
cor(Alcohol ~ Calories, data=subset(NutritionStudy60, Alcohol<25))
@



\section{Two Quantitative Variables: Linear Regression}

When the relationship between variables is sufficiently \emph{linear}, you may be able to predict the value of a variable using the other variable. This is possible by fitting a \emph{regression line}. To plot this in \R, all we need to do is add an additional argument, \argument{type=c("p", "r")}, to the xyplot.
<<linearregression>>=
xyplot(Tip ~ Bill, type=c("p", "r"), data=RestaurantTips)
@

The equation for the regression line, or the \emph{prediction equation} is
\[
\widehat{\mbox{Response}} = a + b \cdot \mbox{Explanatory}
\]

So now, we need to find the values for a, the intercept, and b, the slope using the function to fit linear models.
<<>>=
lm(Tip ~ Bill, data=RestaurantTips)
coef(lm(Tip ~ Bill, data=RestaurantTips))  # just show me the coefficients
@
<<include=FALSE>>=
tip.coefs <- do(1) * lm(Tip ~ Bill, data=RestaurantTips)
@

This results in the equation
\[
\widehat{\mbox{Tip}} = \Sexpr{tip.coefs$Intercept} + \Sexpr{tip.coefs$Bill} \cdot \mbox{Bill}
\]

With this equation, one can predict the tip for different bill amounts.
%There is an easier way to predict.. makeFun?

An important aspect of the linear regression is the difference between the prediction and actual observation. This is called the \term{residual}, defined

\[
\mbox{residual} = \mbox{observed response} - \mbox{predicted response}
\]

%easy way to calculate residuals?

<<>>=
xyplot(AvgMercury ~ pH, type=c("p", "r"), data=FloridaLakes)
lm(AvgMercury ~ pH, data=FloridaLakes)
1.53-0.1523*7.5
1.10-0.388
@




\section{Graphical Summaries -- Important Ideas}

\subsection*{Patterns and Deviations from Patterns}
The goal of a statistical plot is to help us see 
\begin{itemize}
\item 
potential patterns in the data, and 
\item
deviations from those patterns.  
\end{itemize}

\subsection*{Different Plots for Different Kinds of Variables}
Graphical summaries can help us see the \emph{distribution} of a variable 
or the \emph{relationships} between two (or more) variables.  The type of plot
used will depend on the kinds of variables involved. You can use \function{demo()} to see how
to get \R\ to make the plots in this section.

When we do statistical analysis, we will see that the analysis we use will 
also depend on the kinds of variables involved, so this is an important idea.

\subsection*{Side-by-side Plots and Overlays Can Reveal Importance of Additional Factors}
The \pkg{lattice} graphics plots make it particularly easy to generate plats that 
divide the data into groups and either produce a panel for each group (using \verb!|!)
or display each group in a different way (different colors or symbols, using 
the \argument{groups} argument).  These plots can reveal the 
possible influence of additional variables -- sometimes called covariates.

\subsection*{Area = (relative) frequency}

Many plots are based on the key idea that our eyes are good at comparing areas.  Plots 
that use area (e.g., histograms, mosaic plots, bar charts, pie charts) should always obey
this principle
\begin{center}
\large
Area $=$ (relative) frequency
\end{center}
Plots that violate this principle can be deceptive and distort the true nature
of the data.  

\subsection*{An Example: Histogram with unequal bin widths}

It is possible to make histograms with bins that have different widths.
But in this case it is important that the height of the bars is chosen so 
that area (\emph{NOT height}) is proportional to frequency.  
Using height instead of area would distort the picture.

When unequal bin sizes are specified, \function{histogram()} by default chooses
the density scale:
<<hist-unequal-bins,fig.width=3,fig.height=2>>=
histogram( ~ Sepal.Length, data=iris, breaks=c(4,5,5.5,5.75,6,6.5,7,8,9))
@
The density scale is important.
It tells \R\ to use a scale such that 
the area (height $\times$ width) of the rectangles is equal to the relative frequency.
For example, the bar from 5.0 to 5.5 has width $\frac12$ and height about $0.36$, so 
the area is $0.18$, which means approximately 18\% of the sepal lengths are 
between 5.0 and 5.5.

It would be incorrect to choose \option{type="count"} or \option{type="proportion"} since
this distorts the picture of the data.  Fortunately, \R\ will warn you if you try:
<<hist-unequal-bins-bad-echo,fig.width=3,fig.height=2,eval=FALSE>>=
histogram( ~ Sepal.Length, data=iris, breaks=c(4,5,5.5,5.75,6,6.5,7,8,9), type='count')
@
<<hist-unequal-bins-bad,fig.width=3,fig.height=2,echo=FALSE>>=
trellis.par.set(theme=col.mosaic(bw=TRUE))
histogram( ~ Sepal.Length, data=iris, breaks=c(4,5,5.5,5.75,6,6.5,7,8,9),type="count")
trellis.focus('panel',1,1)
grid.text(y=.7,'Never do this!', gp=gpar(col='red',cex=2,alpha=.6))
trellis.unfocus()
trellis.par.set(theme=col.mosaic())
@

Notice how different this looks.  Now the heights are equal to the relative
frequency, but this makes the wider bars have too much area.




\section*{More on Plots}
There are lots of arguments that control how these plots look.  Here are just a
few examples, some of which we have already seen.

\subsection*{auto.key}

\option{auto.key=TRUE} turns on a simple legend for the grouping variable.  
(There are ways to have more control, if you need it.)

<<iris-xyplot-key,cache=TRUE,fig.width=2.6,fig.height=2.4>>=
xyplot(Sepal.Length ~ Sepal.Width, groups=Species, data=iris, 
	auto.key=TRUE)   
@

\subsection*{alpha, cex}
Sometimes it is nice to have elements of a plot be partly transparent.  When
such elements overlap, they get darker, showing us where data are ``piling up."
Setting the \argument{alpha} argument to a value between 0 and 1 controls the
degree of transparency: 1 is completely opaque, 0 is invisible.  The
\argument{cex} argument controls ``character expansion" and can be used to make
the plotting ``characters" larger or smaller by specifying the scaling ratio.

Here is another example using data on 150 iris plants of three species.
<<iris-xyplot-alpha,cache=TRUE,fig.width=2.7,fig.height=2.2>>=
xyplot(Sepal.Length ~ Sepal.Width, groups=Species, data=iris, 
	auto.key=list(columns=3),
	alpha=.5,
	cex=1.3)   
@

\subsection*{main, sub, xlab, ylab}

You can add a title or subtitle, or change the default labels of the axes.
<<iris-xyplot-text,cache=TRUE,fig.width=3,fig.height=2.5>>=
xyplot(Sepal.Length ~ Sepal.Width, groups=Species, data=iris, 
	main="Some Iris Data",
	sub="(R. A. Fisher analysized this data in 1936)",
	xlab="sepal width (cm)",
	ylab="sepal length (cm)",
	alpha=.5,        
	auto.key=list(columns=3))   
@

\subsection*{layout}

\option{layout} can be used to control the arrangement of panels in a multi-panel
plot.  The format is
<<eval=FALSE>>=
layout=c(cols,rows)
@
where \code{cols} is the number of columns and \code{rows} is the number of 
rows.  (Columns first because that is the $x$-coordinate of the plot.)

\subsubsection*{lty, lwd, pch, col}
These can be used to change the line type, line width, plot character, and
color.  To specify multiples (one for each group), use the \function{c()} function 
(see below).

<<pch-lwd-lty,cache=TRUE,fig.width=3,fig.height=2.2>>=
densityplot( ~age, data=HELPrct, groups=sex, lty=1, lwd=c(2,4) )
histogram( ~ age, data=HELPrct, col='green')
@
<<col,fig.width=6,fig.height=2.6,tidy=FALSE>>=
# There are 25 numbered plot symbols; pch=plot character
xyplot( mcs ~ age, data=HELPrct, groups=sex, 
	    pch=c(1,2), col=c('brown', 'darkgreen'), cex=.75 )  
@

Note: If you change this this way, they will \emph{not} match what is 
generated in the legend using \argument{auto.key=TRUE}.  So it can be better
to set these things in a different way if you are using \option{groups}.  
See below.

You can a list of the hundreds of available color names using
\Rindex{colors()}%
<<colors,eval=FALSE>>=
colors()
@

\subsection*{trellis.par.set()}
Default settings for lattice graphics are set using 
\function{trellis.par.set()}.
Don't like the default font sizes?  You can change to a 7 point (base) font using

<<fontsize,eval=TRUE>>=
trellis.par.set(fontsize=list(text=7))    # base size for text is 7 point 
@

Nearly every feature of a lattice plot can be controlled: fonts, colors,
symbols, line thicknesses, colors, etc.  Rather than describe them all here,
we'll mention only that groups of these settings 
can be collected into a theme.  
\function{show.settings()} will show you what the theme looks like.

<<themes-whitbg,cache=TRUE,fig.height=5,fig.width=6>>=
trellis.par.set(theme=col.whitebg())      # a theme in the lattice package
show.settings()
@
\newpage

<<themes-mosaic,cache=TRUE,fig.height=4.0,fig.width=6,out.height='.4\\textheight'>>=
trellis.par.set(theme=col.mosaic())          # a theme in the mosaic package
show.settings()
@
<<themes-mosaic2,cache=TRUE,fig.height=4,fig.width=6,out.height='.4\\textheight'>>=
trellis.par.set(theme=col.mosaic(bw=TRUE))   # black and white version
show.settings()
@

<<themes-mosaic-redo>>=
trellis.par.set(theme=col.mosaic())       # back to the mosaic theme
trellis.par.set(fontsize=list(text=9))    # and back to a 9 point font
@

Want to save your settings?
<<save-settings>>=
# save current settings
mySettings <- trellis.par.get()
# switch to mosaic defaults
trellis.par.set(theme=col.mosaic())
# switch back to my saved settings
trellis.par.set(mySettings)
@

%\subsection*{Working with Pre-Tabulated Data}
%
%Sometimes data arrive pre-calculated.  We can use \function{barchart()} instead of \function{bargraph()}
%to graph pre-tabulated data.%
%\footnote{\function{bargraph()} converts raw data into a summary table and then
%calls \function{barchart()} to do the plotting.}
%<<teen-deaths>>=
%TeenDeaths
%barchart(deaths ~ cause, data=TeenDeaths)
%barchart(cause ~ deaths, data=TeenDeaths)
%@
%
%Notice that by default the causes are displayed in alphabetical order.  \R\ assumes that categorical
%data is nominal unless you say otherwise.  Here's one way to make it ordinal using the order in which 
%things appear in the \dataframe{TeenDeaths} data frame.
%<<teen-deaths-reordered>>=
%barchart( ordered(cause, levels=cause) ~ deaths, TeenDeaths)
%@

\section*{Exporting Plots}

You can save plots to files or copy them to the clipboard using the 
\tab{Export} menu in the \tab{Plots} tab.  It is quite simple to copy the 
plots to the clipboard and then paste them into a Word document, for example.
You can even adjust the height and width of the plot first to get it the 
shape you want.

\R\ code and output can be copied and pasted as well.  It's best to use a 
fixed width font (like Courier) for \R\ code so that things align properly.

\RStudio\ also provides a way (actually multiple ways) to create documents
that include text, \R\ code, \R\ output, and graphics all in one document so you don't 
have to do any copying and pasting.  This is a much better workflow since it avoids 
copy-and-paste which is error prone and makes it easy to regenerate an entire report
should the data change (because you get more of it or correct an error, for example).

\newpage

\section*{Exercises}

For problems 1--\ref{prob:CPSmulti},
include both the plots and the code you used to make them as well as any
required discussion.  Once you get the plots figured out, feel free to 
use some of the bells and whistles to make the plots even better.

\begin{problem}
  Use \R's help system to find out what the \variable{i1} and \variable{i2}
	variables are in the \dataframe{HELPrct} data frame.  Make histograms
	for each variable and comment on what you find out.  How would you describe
	the shape of these distributions?  Do you see any outliers (observations
	that don't seem to fit the pattern of the rest of the data)?  
\end{problem}

\begin{problem}
  Compare the distributions of \variable{i1} and \variable{i2} among men
  and women.
\end{problem}
\begin{solution}
<<>>=
densityplot( ~i1, groups=sex, data=HELPrct )
densityplot( ~i2, groups=sex, data=HELPrct )
@
\end{solution}

\begin{problem}
	Compare the distributions of \variable{i1} and \variable{i2} among 
	the three \variable{substance} groups.
\end{problem}
\begin{solution}
<<>>=
densityplot( ~i1, groups=substance, data=HELPrct )
densityplot( ~i2, groups=substance, data=HELPrct )
@
<<>>=
densityplot( ~i1|sex, groups=substance, data=HELPrct )
densityplot( ~i2|sex, groups=substance, data=HELPrct )
@
<<>>=
xyplot( i2 ~ i1, groups=sex, data= HELPrct, alpha=.6, cex=.6 )
@
\end{solution}

\begin{problem}
	\label{prob:CPS1}
	Where do the data in the \dataframe{CPS85} data frame (in the 
	\pkg{mosaic} package) come from?  What are the observational 
	units?  How many are there?
\end{problem}

\begin{problem}
	Choose a quantitative variable that interests you in the \dataframe{CPS85}
	data set.  Make an appropriate plot and comment on what you see.
\end{problem}

\begin{problem}
	Choose a categorical variable that interests you in the \dataframe{CPS85}
	data set.  Make an appropriate plot and comment on what you see.
\end{problem}

\begin{problem}
	\label{prob:CPSmulti}
	Create a plot that displays two or more variables from the 
	\dataframe{CPS85} data.  At least one should be quantitative 
	and at least one should be categorical.
	Comment on what you can learn from your plot.
\end{problem}


\begin{problem}
The \dataframe{fusion2} data set in the \pkg{fastR} package contains genotypes for 
another SNP.  Merge \dataframe{fusion1}, \dataframe{fusion2}, and \dataframe{pheno} into a single data
frame.

Note that \dataframe{fusion1} and \dataframe{fusion2} have the same columns.
<<>>=
head(fusion1,2)
head(fusion2,2)
@
You may want to use the \option{suffixes} argument to \function{merge()} or rename the variables
after you are done merging to make the resulting data frame easier to navigate.

Tidy up your data frame by dropping any columns that are redundant or that you just don't want to
have in your final data frame.
\end{problem}

\begin{problem}

\end{problem}

\shipoutProblems